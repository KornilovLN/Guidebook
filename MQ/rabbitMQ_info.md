## Информация о применении RabbitMQ:

### Применение: для асинхронного обмена сообщениями между сервисами

- Объем: зависит от нагрузки, обычно несколько ГБ
- Скорость: высокая пропускная способность
- Установка: через пакетный менеджер или Docker

    Выбор зависит от конкретных задач и требований проекта.

### Пример для rabbitMQ:

1. Отправка сообщения:
```
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

channel.queue_declare(queue='hello')

channel.basic_publish(exchange='',
                      routing_key='hello',
                      body='Привет, RabbitMQ!')

print("Сообщение отправлено")
connection.close()
```
2. Получение сообщения:
```
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = connection.channel()

channel.queue_declare(queue='hello')

def callback(ch, method, properties, body):
    print(f"Получено сообщение: {body}")

channel.basic_consume(queue='hello',
                      auto_ack=True,
                      on_message_callback=callback)

print("Ожидание сообщений. Для выхода нажмите CTRL+C")
channel.start_consuming()
```

### Эти примеры демонстрируют базовую отправку и получение сообщений через RabbitMQ.

3. Приложения в разных контейнерах:

В случае, если приложения находятся в разных контейнерах,
использование RabbitMQ становится еще более актуальным и удобным:

- Создайте отдельный контейнер для RabbitMQ.
- В Docker Compose файле определите сервис RabbitMQ и свяжите его с контейнерами ваших приложений.
- В коде приложений используйте имя сервиса RabbitMQ вместо 'localhost' при подключении.

**_Пример Docker Compose файла:_**
```
version: '3'
services:
  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5672:5672"
      - "15672:15672"

  app1:
    build: ./app1
    depends_on:
      - rabbitmq

  app2:
    build: ./app2
    depends_on:
      - rabbitmq
```

В коде приложений измените строку подключения:
```
connection = pika.BlockingConnection(pika.ConnectionParameters('rabbitmq'))
```

Это позволит вашим контейнеризированным приложениям эффективно обмениваться сообщениями через RabbitMQ.

```
ports:
      - "5672:5672"
      - "15672:15672"  порты для 2-х разных контейнеров app1 и app2? и к каким app они относятся?
```

Эти порты относятся к самому контейнеру RabbitMQ.

- Порт 5672 - это стандартный порт для AMQP протокола используется для взаимодействия с RabbitMQ.
- Порт 15672 - это порт для веб-интерфейса управления RabbitMQ.

Оба эти порта принадлежат контейнеру RabbitMQ и позволяют взаимодействовать с ним из других контейнеров или с хост-машины.
App1 и app2 будут использовать эти порты для подключения к RabbitMQ,
но сами эти приложения не обязательно должны открывать какие-либо порты,
если им не нужно прямое внешнее подключение.

**_Если контейнеров много, то они будут общаться через контейнер rabbitMQ_**

Для адресации сообщений конкретным получателям и организации ответов используются следующие механизмы:

- Очереди: Каждый сервис может иметь свою уникальную очередь для получения сообщений.
- Обмены (Exchanges): Позволяют маршрутизировать сообщения в нужные очереди.
- Ключи маршрутизации (Routing keys): Определяют, в какую очередь должно попасть сообщение.
- Паттерн издатель-подписчик: Для широковещательной рассылки.
- RPC через RabbitMQ: Для запросов, требующих ответа.

Контейнеры эффективно обмениваются сообщениями,
указывая нужные очереди или ключи маршрутизации,
а также ожидая ответы на конкретные запросы.

**_Очереди и другие механизмы должны быть описаны_** 

Очереди и другие механизмы обычно описываются в коде каждого контейнера-приложения,
которые общаются через RabbitMQ.
Вот пример:

В контейнере-отправителе:
```
channel.queue_declare(queue='task_queue', durable=True)
channel.basic_publish(
    exchange='',
    routing_key='task_queue',
    body=message,
    properties=pika.BasicProperties(
        delivery_mode=2,  # делает сообщение постоянным
    ))
```

В контейнере-получателе:
```
channel.queue_declare(queue='task_queue', durable=True)
channel.basic_consume(queue='task_queue', on_message_callback=callback)
```

Эти настройки определяются в коде приложений,
а RabbitMQ контейнер предоставляет инфраструктуру для их реализации.
Таким образом, каждое приложение может гибко настраивать свои очереди и обмены в соответствии с потребностями.

**_Книги по RabbitMQ или статьи_**

- Книга "RabbitMQ в действии" (перевод книги "RabbitMQ in Action") - отличное руководство.
- Статья "Введение в RabbitMQ" на Хабре - хороший обзор основных концепций.
- Серия статей "RabbitMQ для начинающих" на сайте Tproger - пошаговое руководство по работе с RabbitMQ.
- Книга "Распределенные системы. Паттерны проектирования" (есть глава про RabbitMQ).
- Официальная документация RabbitMQ (есть перевод на русский) - исчерпывающий источник информации.
